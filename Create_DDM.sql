-- Generated by Oracle SQL Developer Data Modeler 20.2.0.167.1538
--   at:        2020-12-17 19:15:19 EET
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE angajati (
    id_angajat       CHAR(15 CHAR) NOT NULL,
    nume_angajat     VARCHAR2(30 CHAR) NOT NULL,
    prenume_angajat  VARCHAR2(30 CHAR) NOT NULL,
    cnp              VARCHAR2(15 CHAR) NOT NULL,
    functie          VARCHAR2(15 CHAR) NOT NULL
);

ALTER TABLE angajati
    ADD CONSTRAINT angajat_nume_ck CHECK ( REGEXP_LIKE ( nume_angajat,
                                                         '[A-Za-z]+' ) );

ALTER TABLE angajati
    ADD CONSTRAINT angajati_prenume_ck CHECK ( REGEXP_LIKE ( prenume_angajat,
                                                             '[A-Za-z]+' ) );

ALTER TABLE angajati
    ADD CONSTRAINT angajati_cnp_ck CHECK ( length(cnp) = 14 );

ALTER TABLE angajati ADD CONSTRAINT angajati_pk PRIMARY KEY ( id_angajat );

ALTER TABLE angajati ADD CONSTRAINT angajati_cnp_un UNIQUE ( cnp );

CREATE TABLE celule (
    id_celula   CHAR(16 CHAR) NOT NULL,
    capacitate  NUMBER(2) NOT NULL,
    etaj        NUMBER(2) NOT NULL
);

ALTER TABLE celule ADD CONSTRAINT celule_pk PRIMARY KEY ( id_celula );

CREATE TABLE detalii_angajat (
    adresa_angajat       VARCHAR2(60) NOT NULL,
    telefon_angajat      VARCHAR2(10) NOT NULL,
    email_angajat        VARCHAR2(40) NOT NULL,
    angajati_id_angajat  CHAR(15 CHAR) NOT NULL
);

ALTER TABLE detalii_angajat
    ADD CONSTRAINT detalii_telefon_angajat_ck CHECK ( REGEXP_LIKE ( telefon_angajat,
                                                                    '07\d{8}' ) );

ALTER TABLE detalii_angajat
    ADD CONSTRAINT detalii_email_angajat_ck CHECK ( REGEXP_LIKE ( email_angajat,
                                                                  '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );

CREATE UNIQUE INDEX detalii_angajat__idx ON
    detalii_angajat (
        angajati_id_angajat
    ASC );

CREATE TABLE detinuti (
    id_detinut  CHAR(15 CHAR) NOT NULL,
    nume        VARCHAR2(30 CHAR) NOT NULL,
    prenume     VARCHAR2(30) NOT NULL,
    cnp         VARCHAR2(20) NOT NULL,
    adresa      VARCHAR2(100) NOT NULL
);

ALTER TABLE detinuti
    ADD CONSTRAINT detinuti_nume_ck CHECK ( REGEXP_LIKE ( nume,
                                                          '[A-Za-z]+' ) );

ALTER TABLE detinuti
    ADD CONSTRAINT detinuti_prenume_ck CHECK ( REGEXP_LIKE ( prenume,
                                                             '[A-Za-z]+' ) );

ALTER TABLE detinuti
    ADD CONSTRAINT detinuti_cnp_ck CHECK ( length(cnp) = 14 );

ALTER TABLE detinuti ADD CONSTRAINT detinuti_pk PRIMARY KEY ( id_detinut );

ALTER TABLE detinuti ADD CONSTRAINT detinuti_cnp_un UNIQUE ( cnp );

CREATE TABLE detinuti_celule (
    celule_id_celula     CHAR(16 CHAR) NOT NULL,
    data_inceput         DATE NOT NULL,
    data_sfarsit         DATE,
    detinuti_id_detinut  CHAR(15 CHAR) NOT NULL
);

CREATE TABLE fapte (
    id_fapta  CHAR(16 CHAR) NOT NULL,
    nume      CHAR(16 BYTE) NOT NULL,
    ani       NUMBER(3) NOT NULL
);

ALTER TABLE fapte ADD CONSTRAINT fapte_pk PRIMARY KEY ( id_fapta );

CREATE TABLE fise (
    id_fisa              CHAR(16 CHAR) NOT NULL,
    data_incarcerarii    DATE NOT NULL,
    detinuti_id_detinut  CHAR(15 CHAR) NOT NULL
);

ALTER TABLE fise ADD CONSTRAINT fise_pk PRIMARY KEY ( id_fisa );

CREATE TABLE relation_10 (
    fapte_id_fapta       CHAR(16 CHAR) NOT NULL,
    detinuti_id_detinut  CHAR(15 CHAR) NOT NULL
);

ALTER TABLE relation_10 ADD CONSTRAINT relation_10_pk PRIMARY KEY ( fapte_id_fapta,
                                                                    detinuti_id_detinut );

CREATE TABLE ture (
    tura_angajat         NUMBER(1) NOT NULL,
    data_tura            DATE NOT NULL,
    angajati_id_angajat  CHAR(15 CHAR) NOT NULL,
    celule_id_celula     CHAR(16 CHAR) NOT NULL
);



ALTER TABLE detalii_angajat
    ADD CONSTRAINT detalii_angajat_angajati_fk FOREIGN KEY ( angajati_id_angajat )
        REFERENCES angajati ( id_angajat );

ALTER TABLE detinuti_celule
    ADD CONSTRAINT detinuti_celule_celule_fk FOREIGN KEY ( celule_id_celula )
        REFERENCES celule ( id_celula );

ALTER TABLE detinuti_celule
    ADD CONSTRAINT detinuti_celule_detinuti_fk FOREIGN KEY ( detinuti_id_detinut )
        REFERENCES detinuti ( id_detinut );

ALTER TABLE fise
    ADD CONSTRAINT fise_detinuti_fk FOREIGN KEY ( detinuti_id_detinut )
        REFERENCES detinuti ( id_detinut );

ALTER TABLE relation_10
    ADD CONSTRAINT relation_10_detinuti_fk FOREIGN KEY ( detinuti_id_detinut )
        REFERENCES detinuti ( id_detinut );

ALTER TABLE relation_10
    ADD CONSTRAINT relation_10_fapte_fk FOREIGN KEY ( fapte_id_fapta )
        REFERENCES fapte ( id_fapta );

ALTER TABLE ture
    ADD CONSTRAINT ture_angajati_fk FOREIGN KEY ( angajati_id_angajat )
        REFERENCES angajati ( id_angajat );

ALTER TABLE ture
    ADD CONSTRAINT ture_celule_fk FOREIGN KEY ( celule_id_celula )
        REFERENCES celule ( id_celula );

CREATE SEQUENCE angajati_id_angajat_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER angajati_id_angajat_trg BEFORE
    INSERT ON angajati
    FOR EACH ROW
    WHEN ( new.id_angajat IS NULL )
BEGIN
    :new.id_angajat := angajati_id_angajat_seq.nextval;
END;
/

CREATE SEQUENCE celule_id_celula_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER celule_id_celula_trg BEFORE
    INSERT ON celule
    FOR EACH ROW
    WHEN ( new.id_celula IS NULL )
BEGIN
    :new.id_celula := celule_id_celula_seq.nextval;
END;
/

CREATE SEQUENCE d_id_detinut_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER d_id_detinut_trg BEFORE
    INSERT ON detinuti
    FOR EACH ROW
    WHEN ( new.id_detinut IS NULL )
BEGIN
    :new.id_detinut := d_id_detinut_seq.nextval;
END;
/

CREATE SEQUENCE fapte_id_fapta_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER fapte_id_fapta_trg BEFORE
    INSERT ON fapte
    FOR EACH ROW
    WHEN ( new.id_fapta IS NULL )
BEGIN
    :new.id_fapta := fapte_id_fapta_seq.nextval;
END;
/

CREATE SEQUENCE fise_id_fisa_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER fise_id_fisa_trg BEFORE
    INSERT ON fise
    FOR EACH ROW
    WHEN ( new.id_fisa IS NULL )
BEGIN
    :new.id_fisa := fise_id_fisa_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             9
-- CREATE INDEX                             1
-- ALTER TABLE                             25
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                           5
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          5
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0


--creare pachet

CREATE OR REPLACE PACKAGE DETINUTI_PKG AS
    
    PROCEDURE CREEAZA_DETINUT(NUME VARCHAR2, PRENUME VARCHAR2, CNP VARCHAR2, ADRESA VARCHAR2);
    FUNCTION IDENTIFICA_LUNA(luna_cautarii DATE) RETURN VARCHAR2;
    FUNCTION SALARIU_ANGAJAT(p_id_angajat INTEGER, luna_cautarii DATE) RETURN INTEGER;
    
    tura_dubla_in_zi EXCEPTION;
    data_sfarsit_inainte_de_data_inceput EXCEPTION;
    
    PRAGMA EXCEPTION_INIT (tura_dubla_in_zi, -25001);
    PRAGMA EXCEPTION_INIT (data_sfarsit_inainte_de_data_inceput, -25002);
END DETINUTI_PKG;
/
--primeste un nume, prenume, cnp si adresa ca tipuri varchar si le insereaza in tabela detinuti
CREATE OR REPLACE PACKAGE BODY DETINUTI_PKG AS
    PROCEDURE CREEAZA_DETINUT(NUME VARCHAR2, PRENUME VARCHAR2, CNP VARCHAR2, ADRESA VARCHAR2) IS
    BEGIN
        INSERT INTO DETINUTI VALUES(null, NUME, PRENUME, CNP, ADRESA);
    END;

-- functie ajutatoare in care transformam o data intr-un varchar de format mmyyyy
    FUNCTION IDENTIFICA_LUNA(luna_cautarii DATE) RETURN VARCHAR2 IS
    BEGIN
        RETURN CONCAT(
            TO_CHAR(TRUNC(luna_cautarii, 'MM'),'MM'),
            TO_CHAR(TRUNC(luna_cautarii, 'YYYY'),'YYYY'));
    END;
--apeleaza functia precedenta si pe baza id-ului angajatului si a unei date va calcula salariul angajatului in luna specificata pe baza functiei angajatului si a nr de ture lucrate
--folosim un cursor pentru parcurgerea fiecarei ture pe care o are angajatul

    FUNCTION SALARIU_ANGAJAT(p_id_angajat INTEGER, luna_cautarii DATE) RETURN INTEGER IS
        CURSOR ture_anjagat IS
            SELECT angajati.functie, ture.tura_angajat, ture.data_tura FROM angajati 
                INNER JOIN ture ON ture.angajati_id_angajat=angajati.id_angajat
            WHERE ture.angajati_id_angajat=p_id_angajat AND 
            IDENTIFICA_LUNA(luna_cautarii) = IDENTIFICA_LUNA(ture.data_tura);
            
        v_tura ture.tura_angajat%type;       
        v_data_tura ture.data_tura%type;
        v_functie angajati.functie%type;
        v_salariu_per_tura INTEGER;
        v_salariu INTEGER;
    BEGIN
        v_salariu:=0;
        OPEN ture_anjagat;
            LOOP
                FETCH ture_anjagat INTO v_functie, v_tura, v_data_tura;
                EXIT WHEN ture_anjagat%NOTFOUND;
                IF v_functie = 'ingrijitoare' THEN
                    v_salariu_per_tura := 50;
                ELSE
                    v_salariu_per_tura := 150;
                END IF;
                IF v_tura=3 THEN
                    v_salariu_per_tura:=v_salariu_per_tura*2;
                END IF; 
                v_salariu := v_salariu+v_salariu_per_tura;
            END LOOP;
        CLOSE ture_anjagat;

        return v_salariu;
    END;

END DETINUTI_PKG;
/





--creare trigger
--verifica la inserarea in tabela ture ca un angajat nu poate avea mai mult decat o tura in aceeasi zi
CREATE OR REPLACE TRIGGER angajat_tura_dubla_zi_trg
BEFORE INSERT on ture
FOR EACH ROW
DECLARE
    v_tura_existenta int;
BEGIN   
    SELECT COUNT(*) INTO v_tura_existenta FROM ture WHERE 
        DATA_TURA = :NEW.DATA_TURA AND
        ANGAJATI_ID_ANGAJAT = :NEW.ANGAJATI_ID_ANGAJAT;
    IF (v_tura_existenta > 0) THEN 
        RAISE_APPLICATION_ERROR(-20001,'Un angajat nu poate avea doua ture in aceeasi zi');
    END IF;
END;
/
--verifica ca o data de inceput adaugata in tabela detinuti_celule nu este dupa data de sfarsit
CREATE OR REPLACE TRIGGER date_inceput_inainte_data_sfarsit
BEFORE INSERT on detinuti_celule
FOR EACH ROW
BEGIN   
    IF (:NEW.data_inceput >= :NEW.data_sfarsit) THEN 
        RAISE_APPLICATION_ERROR(-20002, 'Data de sfarsit nu poate fi inainte de data de start');
    END IF;
END;
/
--la stergerea unui angajat ii sterge si detaliile si turele din tabelele  detalii_angajati si ture
CREATE OR REPLACE TRIGGER anagajat_cascade_delete
AFTER DELETE ON angajati
FOR EACH ROW
BEGIN
    DELETE FROM DETALII_ANGAJAT WHERE ANGAJATI_ID_ANGAJAT = :OLD.ID_ANGAJAT;
    DELETE FROM TURE WHERE ANGAJATI_ID_ANGAJAT  = :OLD.ID_ANGAJAT;
END;
/